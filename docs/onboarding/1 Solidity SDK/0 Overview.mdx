// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0 <0.9.0;

contract FriendsList {
    struct Friend {
        address walletAddress;
        uint8 position;
        address inviterAddress;
    }

    mapping(uint8 => Friend) public friends;
    mapping(address => uint256) public userBalances;

    uint8 private constant listSize = 8;
    uint8 private currentIndex = 8;
    address private tokenContractAddress;
    uint256 private constant donationAmount = 10 * 10**18;
    uint256 private totalFriends = 0;
    uint256 private nonInviterSubscribers = 0; // New variable to track non-inviter subscribers
    address private burnAddress = 0x000000000000000000000000000000000000dEaD;

    event DonationReceived(address indexed friend, uint256 amount);
    event NewFriendAdded(address indexed friend, address indexed inviter);
    event FriendDropped(address indexed friend, address indexed dropper);

    modifier validPosition(uint8 position) {
        require(position >= 1 && position <= listSize, "Invalid position");
        _;
    }

    modifier onlyFirstFriends() {
        require(totalFriends < 500, "Maximum number of friends reached");
        _;
    }

    constructor(address _tokenContractAddress) {
        tokenContractAddress = _tokenContractAddress;
    }

    function joinList(address inviterAddress) external onlyFirstFriends {
        require(friends[currentIndex].walletAddress == address(0), "List is full");
        require(inviterAddress == address(0) || nonInviterSubscribers < 500, "Maximum number of non-inviter subscribers reached");

        friends[currentIndex].walletAddress = msg.sender;
        friends[currentIndex].position = currentIndex;
        friends[currentIndex].inviterAddress = inviterAddress;

        emit NewFriendAdded(msg.sender, inviterAddress);
        currentIndex--;

        // Update user balance
        userBalances[msg.sender] += donationAmount;

        // Perform compulsory withdrawal from new user
        require(
            IERC20(tokenContractAddress).transferFrom(msg.sender, address(this), donationAmount),
            "Failed to transfer tokens from the friend"
        );

        // Update user balance after withdrawal
        userBalances[msg.sender] -= donationAmount;

        // Distribute the amount to all friends
        uint256 amountToDistribute = donationAmount / listSize;
        for (uint8 i = currentIndex + 1; i <= listSize; i++) {
            IERC20(tokenContractAddress).transfer(friends[i].walletAddress, amountToDistribute);
            emit DonationReceived(friends[i].walletAddress, amountToDistribute);
            friends[i].position--;
        }

        // Burn the remaining tokens
        IERC20(tokenContractAddress).transfer(burnAddress, amountToDistribute * 2);

        if (inviterAddress == address(0)) {
            nonInviterSubscribers++;
        }
        
        if (currentIndex == 1) {
            address dropper = friends[1].walletAddress;
            delete friends[1];
            emit FriendDropped(dropper, msg.sender);
        }
    }

   
    function getFriend(uint8 position) external view validPosition(position) returns (address) {
        return friends[position].walletAddress;
    }

    function transfer(address recipient, uint256 amount) external returns (bool) {
        // Call the transfer function of the token contract to transfer the funds to the recipient
        bool success = IERC20(tokenContractAddress).transfer(recipient, amount);
        return success;
    }
}

interface IERC20 {
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    function transfer(address recipient, uint256 amount) external returns (bool);
}
